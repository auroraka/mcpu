ADDSP3 R0 0x0000
ADDSP3 R0 0x0000
NOP

;保存用户程序寄存器的地址 
;0xBF10  0xBF11 BF12 0xBF13 BF14 0xBF15
; R0    R1   R2   R3   R4   R5  

B START ;#0000011
NOP     ;#0000100

DELINT:   ;中断处理程序
	NOP
	NOP
	NOP
	;保存用户程序现场
	LI R6 0xBF
	SLL R6 R6 0x0000
	ADDIU R6 0x10					;R6=0xBF10
	SW R6 R0 0x0000
	SW R6 R1 0x0001
	SW R6 R2 0x0002
	

	

	
	;R1=中断号
	LW_SP R1 0x0000
	ADDSP 0x0001
	LI R0 0x00FF
	AND R1 R0
	
	;R2=应用程序的pc
	LW_SP R2 0x0000
	ADDSP 0x0001
	
	;保存r3
	ADDSP 0xFFFF
	SW_SP R3 0x0000


	
	;保存用户程序返回地址
	ADDSP 0xFFFF
	SW_SP R7 0x0000
	
	;提示终端，进入中断处理
	LI R3 0x000F
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00
	SW R6 R3 0x0000
	NOP
	;输出中断号
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00 
	SW R6 R1 0x0000
	NOP
	
	;提示终端，中断处理结束
	LI R3 0x000F
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00 
	SW R6 R3 0x0000
	NOP
	
	;R6保存返回地址
	ADDIU3 R2 R6 0x0000
	
	;用r3=IH（高位变成1）
	MFIH R3
	LI R0 0x0080
	SLL R0 R0 0x000
	OR R3 R0
	
	;恢复现场
	LI R7 0xBF
	SLL R7 R7 0x0000
	ADDIU R7 0x10					;R7=0xBF10
	LW R7 R0 0x0000
	LW R7 R1 0x0001
	LW R7 R2 0x0002
	
	;r7=用户程序返回地址
	LW_SP R7 0x0000
	
	ADDSP 0x0001
	ADDSP 0x0001
	NOP
	MTIH R3;
	JR R6
	LW_SP R3 0x00FF
	
	NOP	


;init  0x8251
START:
	;初始化IH寄存器，最高位为1时，允许中断，为0时不允许。初始化为0，kernel不允许中断
	LI R0 0x07			;#01001000
	MTIH R0				;#01001001
	;初始化栈地址
	LI R0 0x00BF		;#01001010
	SLL R0 R0 0x0000	;#01001011
	ADDIU R0 0x10		;#01001100			;R0=0xBF10 
	MTSP R0				;#01001101
	NOP					;#01001110
	
	;用户寄存器值初始化
	LI R6 0x00BF 
	SLL R6 R6 0x0000
	ADDIU R6 0x10					;R6=0xBF10 
	LI R0 0x0000
	SW R6 R0 0x0000
	SW R6 R0 0x0001
	SW R6 R0 0x0002
	SW R6 R0 0x0003
	SW R6 R0 0x0004
	SW R6 R0 0x0005
		
	;WELCOME  ;'O'
	MFPC R7			;#01011001
	ADDIU R7 0x0003	;#01011010
	NOP				;#01011011
	B TESTW			;#01011100
	LI R6 0x00BF	;#01011101
	SLL R6 R6 0x0000;#01011110
	LI R0 0x004F	
	SW R6 R0 0x0000	
	NOP
	
	MFPC R7  ;'K'
	ADDIU R7 0x0003  
	NOP
	B TESTW			;#01100101
	LI R6 0x00BF	;#01100110
	SLL R6 R6 0x0000;#01100111
	LI R0 0x004B	;#01101000
	SW R6 R0 0x0000	;#01101001
	NOP				;#01101010
	
	;'\n'
	MFPC R7			;#01101011
	ADDIU R7 0x0003	;#01101100
	NOP				;#01101101
	B TESTW			;#01101110
	LI R6 0x00BF	;#01101111
	SLL R6 R6 0x0000;#01110000
	LI R0 0x000A	;#01110001
	SW R6 R0 0x0000	;#01110010
	NOP				;#01110011
	
	;'>>'
	MFPC R7			;#01110100
	ADDIU R7 0x0003	;#01110101
	NOP				;#01110110
	B TESTW			;#01110111
	LI R6 0x00BF	;#01111000
	SLL R6 R6 0x0000;#01111001
	LI R0 0x000D	;#01111010
	SW R6 R0 0x0000	;#01111011
	NOP				;#01111100
	

	

	

	
BEGIN:          ;检测命令
	;接收字符，保存到r1
	MFPC R7			;#01111101
	ADDIU R7 0x0003	;#01111110
	NOP				;#01111111
	B TESTR			;#10000000
	NOP				;#10000001
	LI R6 0x00BF	;#10000010
	SLL R6 R6 0x0000;#10000011 
	LW R6 R1 0x0000	;#10000100
	LI R6 0x00ff	;#10000101
	AND R1 R6		;#10000110	
	NOP				;#10000111
	

	;检测是否为R命令		
	LI R0 0x0052	;#10001000
	CMP R0 R1		;#10001001
	BTEQZ SHOWREGS	;#10001010
	NOP				;#10001011
	;检测是否为D命令
	LI R0 0x0044	;#10001100
	CMP R0 R1		;#10001101
	BTEQZ SHOWMEM	;#10001110
	NOP				;#10001111
	
	;检测是否为A命令
	LI R0 0x0041	;#10010000
	CMP R0 R1		;#10010001
	BTEQZ GOTOASM	;#10010010
	NOP				;#10010011
	
	;检测是否为U命令
	LI R0 0x0055	;#10010100
	CMP R0 R1		;#10010101
	BTEQZ GOTOUASM	;#10010110
	NOP				;#10010111
	;检测是否为G命令
	LI R0 0x0047	;#10011000
	CMP R0 R1		;#10011001
	BTEQZ GOTOCOMPILE;#10011010
	NOP				;#10011011
	
	B BEGIN			;#10011100
	NOP				;#10011101

;各处理块的入口
GOTOUASM:
	NOP				;#10011110
	B UASM			;#10011111
	NOP				;#10100000
GOTOASM:
	NOP				;#10100001
	B ASM			;#10100010
	NOP				;#10100011
	
GOTOCOMPILE:
	NOP				;#10100100
	B COMPILE		;#10100101
	NOP				;#10100110
  
	
;测试8251是否能写
TESTW:	
	NOP				;#10100111
	LI R6 0x00BF	;#10101000
	SLL R6 R6 0x0000;#10101001
	ADDIU R6 0x0001	;#10101010
	LW R6 R0 0x0000	;#10101011
	LI R6 0x0001	;#10101100
	AND R0 R6		;#10101101
	BEQZ R0 TESTW	;#10101110 BF01&1=0 则等待	
	NOP				;#10101111
	JR R7			;#10110000
	NOP				;#10110001
	

	
;测试8251是否能读
TESTR:	
	NOP				;#10110010
	LI R6 0x00BF	;#10110011
	SLL R6 R6 0x0000;#10110100
	ADDIU R6 0x0001	;#10110101
	LW R6 R0 0x0000	;#10110110
	LI R6 0x0002	;#10110111
	AND R0 R6		;#10111000
	BEQZ R0 TESTR   ;#10111001;BF01&2=0  则等待	
	NOP				;#10111010
	JR R7			;#10111011
	NOP				;#10111100
	
	
SHOWREGS:    ;R命令，打印R0-R5
	LI R1 0x0006	;#10111011   R1递减  
	LI R2 0x0006	;#10111100	 R2不变
	
LOOP:
	LI R0  0x00BF	;#10111101
	SLL R0 R0 0x0000;#10111110
	ADDIU R0 0x0010	;#10111111
	SUBU R2 R1 R3	;#11000000;R2=0,1,2,3
	ADDU R0 R3 R0   ;#11000001;R0=BF10...
	LW R0 R3 0x0000	;#11000010;R3=用户程序的 R0,R1,R2	

	;发送低八位
	MFPC R7			;#11000011
	ADDIU R7 0x0003	;#11000100
	NOP				;#11000101
	B TESTW			;#11000110
	NOP				;#11000111
	LI R6 0x00BF	;#11001000
	SLL R6 R6 0x0000;#11001001 ;R6=BF00	
	SW R6 R3 0x0000	;#11001010
	;发送高八位
	SRA R3 R3 0x0000;#11001011
	MFPC R7			;#11001100
	ADDIU R7 0x0003	;#11001101
	NOP				;#11001110
	B TESTW			;#11001111
	NOP				;#11010000
	LI R6 0x00BF	;#11010001
	SLL R6 R6 0x0000;#11010010;R6=0xBF00	
	SW R6 R3 0x0000	;#11010011
	
	ADDIU R1 0xFFFF	;#11010100
	NOP				;#11010101
	BNEZ R1 LOOP	;#11010110
	NOP				;#11010111
	B BEGIN			;#11011000
	NOP				;#11011001
	
	
SHOWMEM:  ;查看内存	
;D读取地址低位到r5
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000	
	LI R6 0x00FF
	AND R5 R6
	NOP	
	
	;读取地址高位到r1
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R1 0x0000
	LI R6 0x00FF
	AND R1 R6
	NOP	
	
	
	
	;R1存储地址
	SLL R1 R1 0x0000
	OR R1 R5
	
	;读取显示次数低位到R5
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	;读取显示次数高位到R2
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	;R2保存内存个数
	SLL R2 R2 0x0000
	OR R2 R5

	
		;循环发出	
	
MEMLOOP:		
	
	LW R1 R3 0x0000    ;R3为内存数据	

	;发送低八位
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	;发送高八位

	SRA R3 R3 0x0000
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	
	ADDIU R1 0x0001   ;R1=地址加加加
	ADDIU R2 0xFFFF
	NOP
	BNEZ R2 MEMLOOP
	NOP	

	B BEGIN
	NOP		


 ;汇编	
ASM:  
	;A命令读取地址低位到r5
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	;读取地址高位到r1
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R1 0x0000
	LI R6 0x00FF
	AND R1 R6
	NOP	
	
	;R1存储地址
	SLL R1 R1 0x0000
	OR R1 R5
	
	
	
	
	;检测地址是否合法
	LI R0 0x0000
	CMP R0 R1      
  BTEQZ GOTOBEGIN
	NOP	
	
 
	;读取数据低位到R5
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	

	;读取数据高位到R2
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	;R2保存数据
	SLL R2 R2 0x0000
	OR R2 R5
			
	SW R1 R2 0x0000	
	NOP
	
	B ASM
	NOP
	
GOTOBEGIN:
	NOP
	B BEGIN
	NOP
	
	
	
	
;反汇编：将需要反汇编的地址处的值发给终端处理	
UASM:
;读取地址低位到r5
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	;读取地址高位到r1
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R1 0x0000
	LI R6 0x00FF
	AND R1 R6
	NOP	
	
	
	
	;R1存储地址
	SLL R1 R1 0x0000
	OR R1 R5
	
	;读取显示次数低位到R5
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	;读取显示次数高位到R2
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	;R2保存内存个数
	SLL R2 R2 0x0000
	OR R2 R5

	
		;循环发出	
	
UASMLOOP:		
	
	LW R1 R3 0x0000    ;R3为内存数据	

	;发送低八位
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	;发送高八位

	SRA R3 R3 0x0000
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	
	ADDIU R1 0x0001   ;R1=地址加加加
	ADDIU R2 0xFFFF
	NOP
	BNEZ R2 UASMLOOP
	NOP	

	B BEGIN
	NOP			
	
;连续执行
COMPILE:
	;读取地址低位到R5
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	;读取内存高位到R2
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	;R2保存内存地址  传给r6
	SLL R2 R2 0x0000
	OR R2 R5
	ADDIU3 R2 R6 0x0000
	
	
	LI R7 0x00BF
	SLL R7 R7 0x0000
	ADDIU R7 0x0010
	
	LW R7 R5 0x0005
	ADDSP 0xFFFF
	SW_SP R5 0x0000
	
	
	;中断保存在R5中
	MFIH R5
	LI R1 0x0080
	SLL R1 R1 0x000
	OR R5 R1
	
	
	
	;恢复现场
	LW R7 R0 0x0000
	LW R7 R1 0x0001
	LW R7 R2 0x0002
	LW R7 R3 0x0003
	LW R7 R4 0x0004
	
	
	
	MFPC R7
	ADDIU R7 0x0004
	MTIH R5    ;IH高位赋1	
	JR R6
	LW_SP R5 0x0000  ;R5恢复现场
	
	;用户程序执行完毕，返回kernel，保存现场
	NOP
	NOP
	ADDSP 0x0001
	LI R7 0x00BF
	SLL R7 R7 0x0000
	ADDIU R7 0x0010
	
	SW R7 R0 0x0000
	SW R7 R1 0x0001
	SW R7 R2 0x0002
	SW R7 R3 0x0003
	SW R7 R4 0x0004
	SW R7 R5 0x0005
	
	;IH高位赋0
	MFIH R0
	LI R1 0x007F
	SLL R1 R1 0x0000
	LI R2 0x00FF
	OR R1 R2	
	AND R0 R1
	MTIH R0
	
	;给终端发送结束用户程序提示
	LI R1 0x0007
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R1 0x0000		
	B BEGIN
	NOP	
		
	
	




	